#pragma once

#include <Core/types.h>
#include <Core/logging.h>

#include <GL/glew.h>

#include <Graphics/Lighting.hpp>

#include <Math/Matrix4.hpp>
#include <Math/Vector2.hpp>
#include <Math/Vector3.hpp>

static inline void CheckUniformLocationErrors(GLint location, const std::string& name) {
	if (location == -1) {
		LOG_WARNING(name << " is not a valid uniform variable!");
	} else if (location == GL_INVALID_INDEX) {
		LOG_WARNING(name << " is not a uniform variable(may have been optimized out by GLSL");
	} else if (location == GL_INVALID_VALUE) {
		LOG_WARNING("GPU_Program was not a value generated by OpenGL when trying to get location of uniform" << name);
	} else if (location == GL_INVALID_OPERATION) {
		LOG_WARNING("Invalid shader program provided when getting location of uniform " << name);
	}
}

namespace UniformLocation
{
static const U32 MODEL_MATRIX = 0;
static const U32 VIEW_MATRIX = 1;
static const U32 PROJECTION_MATRIX = 2;
}

namespace Uniform
{

inline bool IsValidLocation (GLint location);
inline GLint GetLocation(GLuint shaderID, const std::string& name);
inline GLint GetLocationNoErrorCheck(GLuint shaderID, const std::string& name);

inline void SetInt(GLint location, int value);

inline void SetFloat(GLint location, float value);
inline void SetFloats(GLint startLocation, float* values, int count);

inline void SetVector2(GLint location, Vector2* value);
inline void SetVector2(GLint location, Vector2* values, int count);
inline void SetVector3(GLint location, const Vector3& vector);

inline void SetMatrix4(GLint location, const Matrix4& matrix);

inline void SetDirectionalLight(DirectionalLight* light, U32 lightIndex, GLuint shaderID);
inline void SetPointLight (PointLight* light, U32 lightIndex, GLuint shaderID);

}


inline GLint Uniform::GetLocationNoErrorCheck(GLuint shaderID, const std::string& name) {
	GLint location = glGetUniformLocation(shaderID, name.c_str());
	return location;
}

inline GLint Uniform::GetLocation (GLuint shaderID, const std::string& name) {
	GLint location = glGetUniformLocation(shaderID, name.c_str());

#ifdef ENABLE_UNIFORM_WARNINGS
	CheckUniformLocationErrors(location, name);
#endif
	return location;
}
inline bool Uniform::IsValidLocation (GLint location) {
	bool result = (location == -1 || location == GL_INVALID_INDEX || GL_INVALID_VALUE);
	return result;
}

inline void Uniform::SetInt(GLint location, int value) {
	glUniform1i(location, value);
}

inline void Uniform::SetFloats(GLint startLocation, float* values, int count) {
	glUniform1fv(startLocation, count, values);
}

inline void Uniform::SetVector2 (GLint location, V2* values, int count) {
	glUniform2fv(location, count, &values->x);
}

inline void Uniform::SetFloat(GLint location, float value) {
	glUniform1f(location, value);
}

inline void Uniform::SetVector3(GLint location, const Vector3& vector) {
	glUniform3fv(location, 1, &vector.x);
}

inline void Uniform::SetMatrix4(GLint location, const Matrix4& matrix) {
	glUniformMatrix4fv(location, 1, GL_FALSE, &matrix[0][0]);
}

inline void Uniform::SetDirectionalLight(DirectionalLight* light, U32 lightIndex, GLuint shaderID) {
	GLint directionLoc = Uniform::GetLocation(shaderID, ("directionalLights[" + std::to_string(lightIndex) + "].direction").c_str());
	GLint colorLoc = Uniform::GetLocation(shaderID, ("directionalLights[" + std::to_string(lightIndex) + "].color").c_str());
	GLint ambientLoc = Uniform::GetLocation(shaderID, ("directionalLights[" + std::to_string(lightIndex) + "].ambient").c_str());

	Uniform::SetVector3(directionLoc, light->direction);
	Uniform::SetVector3(colorLoc, light->color);
	Uniform::SetFloat(ambientLoc, light->ambient);
}

inline void Uniform::SetPointLight(PointLight* light, U32 lightIndex, GLuint shaderID) {
	GLint pointLightLocation = Uniform::GetLocation(shaderID, "pointLights[" + std::to_string(lightIndex) + "].position");
	GLint pointLightColorLocation = Uniform::GetLocation(shaderID, "pointLights[" + std::to_string(lightIndex) + "].color");
	GLint pointLightLinearLoc = Uniform::GetLocation(shaderID, "pointLights[" + std::to_string(lightIndex) + "].linear");
	GLint pointLightQuadradicLoc = Uniform::GetLocation(shaderID, "pointLights[" + std::to_string(lightIndex) + "].quadratic");
	GLint pointLightRadiusLoc = Uniform::GetLocation(shaderID, "pointLights[" + std::to_string(lightIndex) + "].radius");

	Uniform::SetVector3(pointLightLocation, light->position);
	Uniform::SetVector3(pointLightColorLocation, light->color);
	Uniform::SetFloat(pointLightLinearLoc, light->linear);
	Uniform::SetFloat(pointLightQuadradicLoc, light->quadratic);
	Uniform::SetFloat(pointLightRadiusLoc, light->GetRadius());
}